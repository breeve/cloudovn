这个问题触及了 K8s 网络虚拟化中一个非常经典且棘手的矛盾：**“上帝视角”的 Kubelet（处于 Node 网络）如何精准探测“深度隔离”的容器（处于隔离的 VPC 网络）？**

Kube-OVN 目前使用 TProxy 的局限性在于，它是在 Node 的网络命名空间（NetNS）层面去做流量截获。当多个 VPC 出现重叠 IP（Overlapping IPs）时，Node 层的路由表或 TProxy 规则就“抓瞎”了，因为它们无法通过目标 IP 分辨这个包到底该去哪个隧道或哪个 Overlay 网段。

要解决这个问题，本质上需要**在探测链路上引入“VPC 上下文”**。以下是几种进阶的解决思路：

---

### 1. eBPF 劫持与 Context 映射 (最优雅的方案)

不再依赖传统的 TProxy 或 iptables，而是利用 **eBPF (tc 或 socket filter)** 挂载在 Kubelet 发出探测包的路径上。

- **思路：** 当 Kubelet 发起探测请求时，eBPF 程序拦截该包。
- **如何识别 VPC：** 虽然 IP 可能重复，但 Kubelet 探测的目标 Pod 在该 Node 上的容器 ID 或网卡设备（veth pair）是唯一的。eBPF 可以维护一张 **目标 IP + 端口 -> 容器 NetNS/VPC ID** 的映射表。
- **动作：** eBPF 直接在内核态将探测包“推”入对应 Pod 的 NetNS，或者通过修改包头的封装信息，强制其进入正确的 OVN 隧道。
- **优势：** 对用户透明，性能极高，完美解决 IP 重复问题。

### 2. 探针转换器：Mutating Webhook (最务实的方案)

既然网络层不通，我们就避开网络层，改用 **`exec` 探针**。

- **思路：** 编写一个 Mutating Webhook。当检测到 Pod 属于自定义 VPC 时，自动将 Pod Spec 中的 `httpGet` 或 `tcpSocket` 探针修改为 `exec` 探针。
- **实现：** 将 `httpGet` 转换为类似 `exec: ["/bin/sh", "-c", "curl -f http://localhost:8080/health"]` 的形式。
- **原理：** `exec` 探针是由 Kubelet 调用容器运行时（CRI），直接在容器内部空间执行的。它天然就在 VPC 的 NetNS 内部，完全不存在 IP 路由问题。
- **局限：** 容器内必须有 `curl` 或类似的二进制工具。

### 3. Node-Local Proxy / Sidecar (分布式网关方案)

效仿 Service Mesh 的思路，在每个 Node 上部署一个感知 VPC 的代理，或者为 Pod 注入一个轻量级 Sidecar。

- **思路：** Kubelet 不直接探测 Pod，而是探测 Node 上的一个“探测代理”。
- **映射：** 为每个 Pod 分配一个 Node 级别唯一的 **影子端口**（Shadow Port）。
- **过程：** Kubelet 访问 `localhost:10001` -> 代理收到请求 -> 代理根据映射表发现 10001 对应 VPC-A 的 Pod-X -> 代理进入该 Pod 的命名空间完成探测并返回结果。

### 4. 使用 Unix Domain Socket (UDS) 绕过网络层

如果业务支持，可以让探针通过挂载共享卷的方式，通过 UDS 进行通信。

- **思路：** Kubelet 通过文件系统路径探测。
- **优势：** 完全不依赖 IP 协议栈，彻底免疫 IP 冲突。
- **劣势：** 需要应用层代码配合，通用性较差。

---

### 总结与建议

| 方案                  | 解决 IP 冲突        | 复杂度        | 侵入性              |
| --------------------- | ------------------- | ------------- | ------------------- |
| **eBPF 拦截**         | 是 (通过元数据映射) | 高 (内核开发) | 低                  |
| **Webhook 转 `exec**` | 是 (本地执行)       | 中            | 中 (需容器内有工具) |
| **影子端口代理**      | 是 (端口隔离)       | 中            | 低                  |

**我的看法：**
如果你有强大的内核/底层开发能力，**eBPF** 是终极解法，它能让 Kube-OVN 在不改变 K8s 标准行为的前提下实现全透明支持。
如果你追求快速落地，**Mutating Webhook 将网络探针转为 `exec` 探针** 是成本最低、收效最快的方案。

你目前的环境里，这些自定义 VPC 的 Pod 主要是运行什么类型的业务？如果容器镜像比较“瘦”（比如 Distroless），`exec` 方案可能就不太好使了。

**针对这个问题，你想深入了解哪种方案的实现细节？或者需要我帮你写一个 Webhook 的伪代码 demo 看看？**
